//! This module contains the AST definitions for the Nessie Language.
//! The AST is a tree-like structure that represents the structure of the
//! source code and potentially contains semantic information.

use crate::r#type::Type;
use crate::reporting::annotation::{Located, Region};
use std::rc::Rc;

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd)]
pub struct Program {
    pub body: Expr,
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd)]
pub struct Expr {
    pub kind: ExprKind,
    pub span: Region,
    pub ty: Option<Type>,
}

impl From<Located<ExprKind>> for Expr {
    fn from(Located { region, value }: Located<ExprKind>) -> Expr {
        Expr {
            kind: value,
            span: region,
            ty: None,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd)]
pub enum ExprKind {
    /// An integer literal
    Int(i64),
    /// A boolean true literal
    True,
    /// A boolean false literal
    False,
    /// A string literal
    String(Rc<str>),
    /// A binary operator expression.
    Binary(BinaryOp, Box<Expr>, Box<Expr>),
    /// A unary operator expression.
    Unary(UnaryOp, Box<Expr>),
    /// An expression wrapped in parentheses.
    Paren(Box<Expr>),
    /// A `let x = e in E` expression.
    Let {
        name: Rc<str>,
        unique_name: Option<UniqueName>,
        binding: Box<Expr>,
        expr: Box<Expr>,
    },
    /// A variable
    Var(Rc<str>, Option<UniqueName>),
    /// A conditional expression
    If {
        cond: Box<Expr>,
        then: Box<Expr>,
        else_: Box<Expr>,
    },
    /// An anonymous function expression
    Function {
        arg: NameDeclaration,
        recursion_var: Option<UniqueName>,
        body: Box<Expr>,
    },
    /// An application expression
    App {
        func: Box<Expr>,
        arg: Box<Expr>,
    },
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd)]
pub struct NameDeclaration {
    /// The name of the variable as is written in the source code.
    pub name: Rc<str>,
    /// A type constraint of the form `x: T = ...`
    pub type_expr: Option<Located<TypeExpr>>,
    /// The unique identifier generated by the type checker.
    pub unique_name: Option<UniqueName>,
    /// The type of the variable as inferred by the type checker or annotated
    /// by the user.
    pub ty: Option<Type>,
}

impl NameDeclaration {
    pub fn new(name: Rc<str>, type_expr: Option<Located<TypeExpr>>) -> Self {
        Self {
            name,
            type_expr,
            unique_name: None,
            ty: None,
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum TypeExpr {
    Var(Rc<str>),
    Function(Box<Located<TypeExpr>>, Box<Located<TypeExpr>>),
    Paren(Box<Located<TypeExpr>>),
}

#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct UniqueName {
    /// The original name in the source code
    pub name: Rc<str>,
    /// The amount of identifiers this one is shadowing
    pub shadow_count: usize,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum BinaryOp {
    // Int operators
    Add,
    Sub,
    Mul,
    Div,
    Mod,
    // Boolean operators
    And,
    Or,
    Xor,
    // String operators
    Concat,
    // Comparison operators
    Eq,
    Ne,
    Lt,
    Le,
    Gt,
    Ge,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum UnaryOp {
    // Int operators
    Neg,
    // Boolean operators
    Not,
}

pub mod prelude {
    pub use super::*;
}
